---
title: 面试题摘选
lang: js
abbrlink: 28f5673f
date: 2022-06-15 17:54:00
categories:
  - js
tags:
 - js 
 - vue
 - css
---

经典函数，算法，或者知识点归类。
<!--more-->
### js相关
#### 数组排序
- 1.乱序
```javaScript
function shuffle(a) {
    for (let i = a.length; i; i--) {
        let j = Math.floor(Math.random() * i);
        [a[i - 1], a[j]] = [a[j], a[i - 1]];
    }
    return a;
}

var times = 100000;
var res = {};

for (var i = 0; i < times; i++) {
    var arr = shuffle([1, 2, 3]);
    var key = JSON.stringify(arr);
    console.log(arr,key)
    res[key] ? res[key]++ :  res[key] = 1;
}

// 为了方便展示，转换成百分比
for (var key in res) {
    res[key] = res[key] / times * 100 + '%'
}

console.log(res)

```

- 2.数组扁平化 + 升序
```javaScript
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})
```

- 3.普通乱序
```javaScript
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    let a = Math.random() - 0.5;
    console.log(a)
    return a;
});
```
- 4.普通升序
```javaScript
function quickSort(arr) {
    if(arr.length <= 1) {
        return arr;  //递归出口
    }
    var left = [],
        right = [],
        current = arr.splice(0,1); 
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] < current) {
            left.push(arr[i])  //放在左边
        } else {
            right.push(arr[i]) //放在右边
        }
    }
    return quickSort(left).concat(current,quickSort(right));
}
```

#### bind call apply
 + 相同点： 都是修改this的指向
 + 不同点： **call , apply 立即执行**，**bind绑定返回新函数，需调用执行**。
         fn.call([this],param...)
         fn.apply([this],[param...])
         fn.bind([this],param...)

```javaScript
    var obj = {
        name: '美美',
        age: 18,
        say: function(){
            console.log(`my name is ${this.name}, I am ${this.age}`)
        }
    }

    var xixi = {
        name: 'xixi', 
        age: 12
    }

    obj.say()
    obj.say.call(xixi) 
    obj.say.apply(xixi)
    obj.say.bind(xixi)()
    ```

 + 参数传递 apply 入参是数组，call, bind 入参是arguments  

```javaScript
    var obj = {
        name: '美美',
        age: 18,
        say: function(from,to){
            console.log(`my name is ${this.name}, I am ${this.age}, from ${from} to ${to}`)
        }
    }

    var xixi = {
        name: 'xixi', 
        age: 12
    }

    obj.say.call(xixi,'beijing','shanghai') 
    obj.say.apply(xixi, ['beijing','shanghai'])
    obj.say.bind(xixi,'beijing','shanghai')()

```

####  深浅拷贝
深浅拷贝都只是针对数组、对象这类引用型数据类型的。
1、什么是深拷贝、浅拷贝
深拷贝：修改新变量的值不会影响原有变量的值，相当于创造一个一模一样的新对象，新旧对象不共享内存
浅拷贝：修改新变量的值会影响原有的变量的值，只复制对象的引用，新旧对象共享同一块内存
2.实现浅拷贝
+ Object.assign({}，obj)
+ Array.prototype.concat() 与 Array.prototype.slice()
+ … 运算符

3、深拷贝实现
+ JSON.parse( JSON.stringify() )
+ 递归
```javaScript
function deepCopy(obj){
    let newObj = null;   
    if(typeof(obj) == 'object' && obj !== null){
        newObj= obj instanceof Array? [] : {};
        for(let i in obj){
            newObj[i] = deepCopy(obj[i])
        }
    }else{
        newObj = obj;
    }
    return newObj;
}

```

#### 什么是跨域？ 怎么解决？
+ 定义
 跨域是浏览器的安全策略，是指： http协议 ，域名，端口不一样
+ 解决：
 + cors: Access-Control-Allow-Origin: * || <指定origin>
 + jsonp:  http://abc.com?callback=handleData ,在handleData 里面处理返回的数据
 + websocket 
 + node 代理转发等
 
#### 从输入URL到页面加载完成期间经历了什么(简写)
+ 1.浏览器根据请求的URL交给DNS域名解析，找到真实IP；
+ 2.浏览器根据 IP 地址向服务器发起 TCP 连接，与浏览器建立 TCP 三次握手
+ 3.发送HTTP请求，接受HTTP响应
+ 5.服务器处理请求并返回内容。
+ 6.根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件，浏览器解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户
+ 7.断开TCP连接（四次挥手）




#### js 冒泡 捕获

捕获优先冒泡
捕获： 由外向内 
冒泡： 由内向外 

参数 默认冒泡 false, true 就是捕获。
div.addEventListener("click",clickhandler,true);

e.stopPropagation() 就是阻止之后的冒泡或者捕获继续传播，说白了就是截断，不再侦听
e.prevent.default(); 阻止默认行为。

#### 闭包
闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。
```javaScript
var myFamily = function(){
    let init = Object.create(null);
    function addPerson(name,age = 0){
        if (init[name]) {
            delete init[name]
        }else{
            init[name] = age
        }
    }
    return {
        getPerson:()=>{
            return init;
        },
        add:(name,age)=>{
            addPerson(name,age)
        },
        del:(name)=>{
            addPerson(name)
        }
    }
}

var huang = myFamily();
huang.add('hai',20)
huang.add('bing',30)
console.log(huang.getPerson())

var tui = myFamily();
tui.add('hai',45)
tui.add('bing',23)
console.log(tui.getPerson())

```


#### js 继承
所谓继承就是通过某种方式让一个对象可以访问到另一个对象中的属性和方法




### CSS 相关

#### 盒子模型 
分成标准盒子模型 和 IE 盒子模型
标准盒子模型(W3C 盒子模型)：content padding margin border
IE盒子模型： content(包含padding + border) margin

`CSS3 box-sizing` 属性 可以切换两个模型。
`box-sizing: content-box|border-box|inherit`
使用IE盒子模型： `box-sizing: border-box`
content-box:默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。
border-box:	告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减 去(border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。

####  BFC 是什么？ 如何实现？ 
定义：
**块格式化上下文（Block Formatting Context，BFC）**是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)
实现：
+ 根元素或其它包含它的元素
+ 浮动元素 (元素的 float 不是 none)
+ 绝对定位元素 (元素具有 position 为 absolute 或 fixed)
+ 内联块 (元素具有 display: inline-block)
+ 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
+ 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
+ 具有overflow 且值不是 visible 的块元素

格式化上下文影响布局，通常，我们会为定位和清除浮动创建新的 BFC，而不是更改布局，因为它将：

包含内部浮动
排除外部浮动
**阻止 外边距重叠**

#### flex 
Flex是Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性会失效。
```css
flex-grow: 默认0 剩余空间扩展比例，最大值1
flex-shrink: 默认1， 收缩比例
flex-basic: 默认auto 指定初始大小 优先级别大于width
```

**flex的六大属性**
+ flex-direction： row | column | row-reverse | column-reverse
+ flex-wrap: nowrap | wrap | wrap-reverse
+ justify-content: center | flex-start | flex-end | space-between | space-around
+ align-items: center flex-start flex-end baseline
+ align-content: flex-start stretch center space-between





### VUE
#### vue 组件通信
+ 父子： props emit 
+ 广播监听 
    ```javaScript
    var Event=new Vue();
    Event.$emit(事件名,数据);
    Event.$on(事件名,data => {})
    ```
+ inject provide
+ vuex

#### nexttick 
`Vue.$nextTick(cb)`
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。

### 其他
#### 宏任务 微任务
js 是单线程，执行顺序 同步 再异步，先微任务 再宏任务。

+ js宏任务有：setTimeout、setInterval、setImmediate、Ajax、DOM事件
+ js微任务有：process.nextTick、MutationObserver、Promise.then catch finally

JS是单线程，碰见同步执行同步直到执行完毕，遇到异步放到执行队列中去，异步(宏任务和微任务)，在异步中微任务是优于宏任务执行的


#### import required 区别

+ 1.模块加载的时间
require：运行时加载
import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】
+ 2.模块的本质
require：模块就是对象，输入时必须查找对象属性
import：ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入

```javaScript
// CommonJS模块
let { exists, readFile } = require('fs');
// 等同于
let fs = require('fs');
let exists = fs.exists;
let readfile = fs.readfile;
```

上面CommonJs模块中，实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法

// ES6模块
```javaScript
import { exists, readFile } from 'fs';
```

上面ES6模块，实质上从fs模块加载2个对应的方法，其他方法不加载

+ 3.严格模式
（1）CommonJs模块默认采用非严格模式
（2）ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 “use strict”;
（3）CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用


#### 虚拟dom  diff？ 
用JavaScript模拟DOM树，并渲染这个DOM树
比较新老DOM树，得到比较的差异对象
把差异对象应用到渲染的DOM树。






