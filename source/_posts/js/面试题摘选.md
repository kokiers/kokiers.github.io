---
title: 面试题摘选
lang: js
abbrlink: 28f5673f
date: 2022-06-15 17:54:00
categories:
  - js
tags:
  - jsFc
---

经典函数，算法，或者知识点归类。
<!--more-->
#### 数组排序
- 1.乱序
```bash
function shuffle(a) {
    for (let i = a.length; i; i--) {
        let j = Math.floor(Math.random() * i);
        [a[i - 1], a[j]] = [a[j], a[i - 1]];
    }
    return a;
}

var times = 100000;
var res = {};

for (var i = 0; i < times; i++) {
    var arr = shuffle([1, 2, 3]);
    var key = JSON.stringify(arr);
    console.log(arr,key)
    res[key] ? res[key]++ :  res[key] = 1;
}

// 为了方便展示，转换成百分比
for (var key in res) {
    res[key] = res[key] / times * 100 + '%'
}

console.log(res)

```

- 2.数组扁平化 + 升序
```bash
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})
```

- 3.普通乱序
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    let a = Math.random() - 0.5;
    console.log(a)
    return a;
});
- 4.普通升序
function quickSort(arr) {
    if(arr.length <= 1) {
        return arr;  //递归出口
    }
    var left = [],
        right = [],
        current = arr.splice(0,1); 
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] < current) {
            left.push(arr[i])  //放在左边
        } else {
            right.push(arr[i]) //放在右边
        }
    }
    return quickSort(left).concat(current,quickSort(right));
}


#### bind call apply
 + 相同点： 都是修改this的指向
 + 不同点： **call , apply 立即执行**，**bind绑定返回新函数，需调用执行**。
         fn.call([this],param...)
         fn.apply([this],[param...])
         fn.bind([this],param...)
```
    var obj = {
        name: '美美',
        age: 18,
        say: function(){
            console.log(`my name is ${this.name}, I am ${this.age}`)
        }
    }

    var xixi = {
        name: 'xixi', 
        age: 12
    }

    obj.say()
    obj.say.call(xixi) 
    obj.say.apply(xixi)
    obj.say.bind(xixi)()

 + 参数传递 apply 入参是数组，call, bind 入参是arguments  
```
    var obj = {
        name: '美美',
        age: 18,
        say: function(from,to){
            console.log(`my name is ${this.name}, I am ${this.age}, from ${from} to ${to}`)
        }
    }

    var xixi = {
        name: 'xixi', 
        age: 12
    }

    obj.say.call(xixi,'beijing','shanghai') 
    obj.say.apply(xixi, ['beijing','shanghai'])
    obj.say.bind(xixi,'beijing','shanghai')()

```

####  深浅拷贝
深浅拷贝都只是针对数组、对象这类引用型数据类型的。
1、什么是深拷贝、浅拷贝
深拷贝：修改新变量的值不会影响原有变量的值，相当于创造一个一模一样的新对象，新旧对象不共享内存
浅拷贝：修改新变量的值会影响原有的变量的值，只复制对象的引用，新旧对象共享同一块内存
2.实现浅拷贝
+ Object.assign({}，obj)
+ Array.prototype.concat() 与 Array.prototype.slice()
+ … 运算符

3、深拷贝实现
+ JSON.parse( JSON.stringify() )
+ 递归
```bash
function deepCopy(obj){
    let newObj = null;   
    if(typeof(obj) == 'object' && obj !== null){
        newObj= obj instanceof Array? [] : {};
        for(let i in obj){
            newObj[i] = deepCopy(obj[i])
        }
    }else{
        newObj = obj;
    }
    return newObj;
}

```
#### 盒子模型
ie盒子模型，标准盒模型
+ ie盒子： 内容宽度 padding border //ie8以上都是标准盒子模型
+ 标准： 内容宽度
+ 切换： 
    box-sizing: border-box;
    box-sizing: content-box;


####  BFC 是什么？ 如何实现？ 
+ 定义：
块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域
+ 实现：
根元素或其它包含它的元素
浮动元素 (元素的 float 不是 none)
绝对定位元素 (元素具有 position 为 absolute 或 fixed)
内联块 (元素具有 display: inline-block)
表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
具有overflow 且值不是 visible 的块元素

#### 什么是跨域？ 怎么解决？
+ 定义
 跨域是浏览器的安全策略，是指： http协议 ，域名，端口不一样
+ 解决：
 + cors: Access-Control-Allow-Origin: * || <指定origin>
 + jsonp:  http://abc.com?callback=handleData ,在handleData 里面处理返回的数据
 + websocket 
 + node 代理转发等
 
#### 从输入URL到页面加载完成期间经历了什么(简写)
+ 1.浏览器根据请求的URL交给DNS域名解析，找到真实IP；
+ 2.浏览器根据 IP 地址向服务器发起 TCP 连接，与浏览器建立 TCP 三次握手
+ 3.发送HTTP请求，接受HTTP响应
+ 5.服务器处理请求并返回内容。
+ 6.根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件，浏览器解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户
+ 7.断开TCP连接（四次挥手）

#### 虚拟dom  diff？ 
用JavaScript模拟DOM树，并渲染这个DOM树
比较新老DOM树，得到比较的差异对象
把差异对象应用到渲染的DOM树。


#### flex 
Flex是Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性会失效。

flex-grow: 默认0 剩余空间扩展比例，最大值1
flex-shrink: 默认1， 收缩比例
flex-basic: 默认auto 指定初始大小 优先级别大于width

+ flex的六大属性
    + flex-direction： row | column | row-reverse | column-reverse
    + flex-wrap: nowrap | wrap | wrap-reverse
    + justify-content: center | flex-start | flex-end | space-between | space-around
    + align-items: center flex-start flex-end baseline
    + align-content: flex-start stretch center space-between







#### vue 组件通信
+ 父子： props emit 
+ 广播监听 
    ```
    var Event=new Vue();
    Event.$emit(事件名,数据);
    Event.$on(事件名,data => {})
    ```
+ inject provide
+ vuex


#### 宏任务 微任务
js 是单线程，执行顺序 同步 再异步，先微任务 再宏任务。

+ js宏任务有：setTimeout、setInterval、setImmediate、Ajax、DOM事件
+ js微任务有：process.nextTick、MutationObserver、Promise.then catch finally

JS是单线程，碰见同步执行同步直到执行完毕，遇到异步放到执行队列中去，异步(宏任务和微任务)，在异步中微任务是优于宏任务执行的


#### import required 区别

+ 1.模块加载的时间
require：运行时加载
import：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】
+ 2.模块的本质
require：模块就是对象，输入时必须查找对象属性
import：ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入

// CommonJS模块
> let { exists, readFile } = require('fs');
// 等同于
> let fs = require('fs');
> let exists = fs.exists;
> let readfile = fs.readfile;

上面CommonJs模块中，实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法

// ES6模块
> import { exists, readFile } from 'fs';

上面ES6模块，实质上从fs模块加载2个对应的方法，其他方法不加载

+ 3.严格模式
（1）CommonJs模块默认采用非严格模式
（2）ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 “use strict”;
（3）CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用





nexttick ??

手动实现promiss

#### js 冒泡 捕获

捕获优先冒泡
捕获： 由外向内 
冒泡： 由内向外 

参数 默认冒泡 false, true 就是捕获。
div.addEventListener("click",clickhandler,true);

e.stopPropagation() 就是阻止之后的冒泡或者捕获继续传播，说白了就是截断，不再侦听
e.prevent.default(); 阻止默认行为。
